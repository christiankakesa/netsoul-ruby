#!/usr/bin/env ruby
# -*- encoding: binary -*-
lib = File.expand_path('../../lib', __FILE__)
$LOAD_PATH.unshift lib unless $LOAD_PATH.include?(lib)

require 'netsoul/config'
require 'netsoul/errors'
require 'netsoul/logging'
require 'netsoul/message'
require 'socket'

module Netsoul
  class Client
    include Logging

    attr_reader :started

    def initialize(*args)
      opts = args.last.is_a?(Hash) ? args.last : {}
      @config = Config.new(opts)
      @started = false
    end

    def auth_ag
      sock_send(Message.auth_ag)
      fail Netsoul::IdentificationError, 'Identification failed.'.freeze unless sock_get.split(' ')[1] == '002'.freeze
    end
    private :auth_ag

    def auth_method
      if @config.auth_method == :krb5
        sock_send(Message.kerberos_auth(@config))
      else
        sock_send(Message.standard_auth(@config))
      end
      fail Netsoul::AuthenticationError, 'Authentication failed.'.freeze unless sock_get.split(' ')[1] == '002'
    end
    private :auth_method

    def auth_status
      sock_send(Message.attach)
      sock_send(Message.user_state(@config.state, Time.now.to_i))
    end
    private :auth_status

    def connect
      @sock = TCPSocket.new(@config.server_host, @config.server_port)
      fail Netsoul::SocketError, 'Could not open a socket. Connection is unavailable.'.freeze unless @sock

      _cmd, _socket_num, md5_hash, client_ip, client_port, _server_timestamp = sock_get.split
      @config.build_user_connection_info md5_hash: md5_hash, client_ip: client_ip, client_port: client_port

      auth_ag
      auth_method
      auth_status
      @started = true
    end

    def disconnect
      sock_send(Message.ns_exit)
    ensure
      sock_close
    end

    def sock_send(str)
      log :info, "[send] #{str.chomp}"
      @sock.puts str
    end

    def sock_get
      res = @sock.gets
      log :info, "[get ] #{res.chomp}"
      res
    end

    def sock_close
      @started = false
      @sock.close
    rescue
      nil
    end
  end
end

$stderr.sync = true
require 'optparse'
require 'yaml'

options = {}
OptionParser.new do |opts|
  opts.banner = 'Usage: netsoul-ruby [options]'.freeze
  opts.separator ''.freeze
  opts.separator 'Netsoul-Ruby options:'.freeze

  opts.on('-c'.freeze, '--config FILE'.freeze, 'Configuration file in YAML'.freeze) do |file|
    options[:config] = file
    unless File.file?(options[:config])
      puts '[ERROR] Configuration is not a valid file'
      exit
    end
    options[:user_opts] = YAML.load_file(options[:config])
  end

  opts.on('-h', '--help', 'Display this screen') do
    puts opts
    exit
  end
end.parse!

unless options.include?(:config)
  puts '[ERROR] Configuration file is not provided'
  exit
end

retry_count = 10
retry_wait_time = 1.0
RETRY_WAIT_FACTOR = 1.25 # Each time retry is called 'retry_wait_time' is increased with this factor
begin
  c = Netsoul::Client.new options[:user_opts]
  c.connect
  if c.started
    retry_count = 10
    retry_wait_time = 1.0
    loop do
      res = c.sock_get
      c.sock_send res if res.to_s.match(/^ping.*/)
      sleep 1
    end
  end
rescue => e
  puts "[ERROR]: #{e}"
  puts "[RETRY_COUNT]: #{retry_count}"
  c.disconnect
  c = nil
  if retry_count > 0
    retry_count -= 1
    retry_wait_time *= RETRY_WAIT_FACTOR
    sleep retry_count
    retry
  end
end
